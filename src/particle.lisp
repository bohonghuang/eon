(in-package #:eon)

(defcstruct particle-3d
  (position (:struct raylib:vector3))
  (position-velocity (:struct raylib:vector3))
  (position-acceleration (:struct raylib:vector3))
  (rotation (:struct raylib:vector4))
  (rotation-velocity (:struct raylib:vector4))
  (rotation-acceleration (:struct raylib:vector4))
  (age :float)
  (lifetime :float)
  (livep :boolean))

(cobj:define-cobject-class (:struct particle-3d))

(declaim (inline particle-3d-velocity))
(defun particle-3d-velocity (instance)
  (particle-3d-position-velocity instance))

(declaim (inline (setf particle-3d-velocity)))
(defun (setf particle-3d-velocity) (value instance)
  (setf (particle-3d-position-velocity instance) value))

(declaim (inline particle-3d-acceleration))
(defun particle-3d-acceleration (instance)
  (particle-3d-position-acceleration instance))

(declaim (inline (setf particle-3d-acceleration)))
(defun (setf particle-3d-acceleration) (value instance)
  (setf (particle-3d-position-acceleration instance) value))

(deftype particle-3d-updater ()
  '(function (particle-3d)))

(defconstant +particle-3d-emitter-default-capacity+ 128)

(defstruct (particle-3d-emitter (:constructor %make-particle-3d-emitter))
  (particles nil :type (simple-array particle-3d (*)))
  (updater #'values :type particle-3d-updater))

(declaim (ftype (function (&key (:capacity positive-fixnum) (:updater particle-3d-updater)) (values particle-3d-emitter)) make-particle-3d-emitter))
(defun make-particle-3d-emitter (&key (capacity +particle-3d-emitter-default-capacity+) (updater #'values))
  (loop :with particles :of-type (simple-array particle-3d (*)) := (cobj:ccoerce (cobj:make-carray capacity :element-type 'particle-3d) 'simple-array)
        :for particle :across particles
        :do (setf (particle-3d-livep particle) nil)
        :finally (return (%make-particle-3d-emitter :particles particles :updater updater))))

(deftype particle-3d-renderer () '(function (particle-3d)))

(declaim (ftype (function (particle-3d-emitter non-negative-fixnum) (values boolean)) particle-3d-emitter-emit))
(defun particle-3d-emitter-emit (emitter count)
  (loop :with particles :of-type (simple-array particle-3d (*)) := (particle-3d-emitter-particles emitter)
        :for particle :across particles
        :when (>= emitted count)
          :return t
        :unless (particle-3d-livep particle)
          :do (setf (particle-3d-age particle) 0.0
                    (particle-3d-livep particle) t)
          :and :count 1 :into emitted :of-type non-negative-fixnum))

(declaim (ftype (function (foreign-pointer foreign-pointer single-float) (values foreign-pointer)) %quaternion-scale-rotation)
         (inline %quaternion-scale-rotation))
(defun %quaternion-scale-rotation (result quaternion value)
  (clet* ((axis+angle (foreign-alloca '(:struct raylib:vector4)))
          (axis (cthe (:pointer (:struct raylib:vector3)) axis+angle))
          (angle (cthe (:pointer :float) (& (-> axis+angle raylib:w)))))
    (raylib:%quaternion-to-axis-angle quaternion axis angle)
    (raylib:%quaternion-from-axis-angle result axis (* ([] angle) value))
    result))

(defun particle-3d-initialize-default (particle &optional position)
  (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle))))
    (if position
        (csetf (-> particle position) ([] (cthe (:pointer (:struct raylib:vector3)) (& position))))
        (raylib:%vector3-zero (& (-> particle position))))
    (raylib:%vector3-zero (& (-> particle position-velocity)))
    (raylib:%vector3-zero (& (-> particle position-acceleration)))
    (raylib:%quaternion-identity (& (-> particle rotation)))
    (raylib:%quaternion-identity (& (-> particle rotation-velocity)))
    (raylib:%quaternion-identity (& (-> particle rotation-acceleration)))
    (setf (-> particle age) 0.0 (-> particle lifetime) 1.0)))

(defun particle-3d-update-motion (particle &optional (delta (locally (declare (special #1=particle-3d-delta-time)) #1#)))
  (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
         (s (foreign-alloca '(:struct raylib:vector4))))
    (clet ((p (& (-> particle position)))
           (a (& (-> particle position-acceleration)))
           (v (& (-> particle position-velocity))))
      (raylib:%vector3-scale s a delta)
      (raylib:%vector3-add v s v)
      (raylib:%vector3-scale s s 0.5)
      (raylib:%vector3-subtract s v s)
      (raylib:%vector3-scale s s delta)
      (raylib:%vector3-add p p s))
    (clet ((p (& (-> particle rotation)))
           (a (& (-> particle rotation-acceleration)))
           (v (& (-> particle rotation-velocity))))
      (%quaternion-scale-rotation s a delta)
      (raylib:%quaternion-multiply v s v)
      (%quaternion-scale-rotation s s 0.5)
      (raylib:%quaternion-invert s s)
      (raylib:%quaternion-multiply s v s)
      (%quaternion-scale-rotation s s delta)
      (raylib:%quaternion-multiply p p s)
      nil)))

(declaim (ftype (function (particle-3d-emitter &optional single-float)) particle-3d-emitter-update))
(defun particle-3d-emitter-update (emitter &optional (delta (game-loop-delta-time)) &aux (particle-3d-delta-time delta))
  (declare (special particle-3d-delta-time))
  (loop :with particles :of-type (simple-array particle-3d (*)) := (particle-3d-emitter-particles emitter)
        :and updater :of-type (function (particle-3d)) := (particle-3d-emitter-updater emitter)
        :for particle :across particles
        :do (when (particle-3d-livep particle)
              (if (zerop (particle-3d-age particle))
                  (progn
                    (funcall updater particle)
                    (incf (particle-3d-age particle) single-float-epsilon))
                  (incf (particle-3d-age particle) (/ delta (particle-3d-lifetime particle))))
              (if (> (particle-3d-age particle) 1.0)
                  (setf (particle-3d-livep particle) nil)
                  (funcall updater particle)))))

(declaim (ftype (function (particle-3d-emitter particle-3d-renderer)) particle-3d-emitter-draw))
(defun particle-3d-emitter-draw (emitter renderer)
  (loop :with particles :of-type (simple-array particle-3d (*)) := (particle-3d-emitter-particles emitter)
        :for particle :across particles
        :when (particle-3d-livep particle)
          :do (funcall renderer particle)))

(declaim (ftype (function (particle-3d-emitter
                           (function (single-float) single-float)
                           particle-3d-renderer
                           &optional (function () (values single-float)))
                          (function (&optional single-float)))
                particle-3d-emitter-emit-update-draw-function))
(defun particle-3d-emitter-emit-update-draw-function (emitter rate-function renderer &optional (delta #'game-loop-delta-time))
  (let ((rate-fraction 0.0))
    (declare (type single-float rate-fraction))
    (lambda (&optional (delta (funcall delta)))
      (declare (type single-float delta))
      (particle-3d-emitter-emit emitter (multiple-value-bind (count fraction) (truncate (+ (funcall rate-function delta) rate-fraction))
                                          (declare (type non-negative-fixnum count)
                                                   (type single-float fraction))
                                          (setf rate-fraction fraction)
                                          count))
      (particle-3d-emitter-update emitter delta)
      (particle-3d-emitter-draw emitter renderer))))

(declaim (ftype (function (t) (values function)) ensure-value-generator))
(defun ensure-value-generator (value)
  (if (functionp value) value (constantly value)))

(defmacro with-value-generators (values &body body)
  `(let ,(mapcar (lambda (value) `(,value (ensure-value-generator ,value))) values)
     (declare (type function . ,values))
     . ,body))

(deftype particle-3d-value-generator (type)
  `(function (particle-3d) (values ,type)))

(deftype particle-3d-value-or-generator (type)
  `(or (particle-3d-value-generator ,type) ,type))

(cobj:define-global-cobject +vector2-zeros+ (raylib:make-vector2 :x 0.0 :y 0.0))
(cobj:define-global-cobject +vector3-unit-x+ (raylib:make-vector3 :x 1.0 :y 0.0 :z 0.0))
(cobj:define-global-cobject +vector3-unit-y+ (raylib:make-vector3 :x 0.0 :y 1.0 :z 0.0))
(cobj:define-global-cobject +vector3-zeros+ (raylib:make-vector3 :x 0.0 :y 0.0 :z 0.0))

(defun make-particle-3d-vector2-generator (length)
  (etypecase length
    (single-float
     (let ((v (raylib:make-vector2 :x length :y 0.0)))
       (lambda (particle)
         (declare (ignore particle))
         (raylib:%vector2-rotate (& v) (& v) (random (coerce (* pi 2.0) 'single-float))) v)))
    ((cons single-float single-float)
     (let ((v (raylib:make-vector2 :x (car length) :y 0.0)))
       (lambda (particle)
         (declare (ignore particle))
         (raylib:%vector2-normalize (& v) (& v))
         (raylib:%vector2-scale (& v) (& v) (+ (random (- (cdr length) (car length))) (car length)))
         (raylib:%vector2-rotate (& v) (& v) (random (coerce (* pi 2.0) 'single-float)))
         v)))
    (raylib:vector2
     (let ((v (raylib:make-vector2)))
       (lambda (particle &aux (range-x (raylib:vector2-x length)) (range-y (raylib:vector2-y length)))
         (declare (ignore particle))
         (setf (raylib:vector2-x v) (if (plusp range-x) (- (random (* 2.0 range-x)) range-x) 0.0)
               (raylib:vector2-y v) (if (plusp range-y) (- (random (* 2.0 range-y)) range-y) 0.0))
         v)))))

(defmacro derive-particle-3d-vector2-generator (generator-form &rest functions)
  (with-gensyms (generator generated particle)
    (let ((derivations (make-gensym-list (length functions) 'derivation)))
      `(let ((,generator ,generator-form)
             . ,(mapcar (rcurry #'list `(raylib:make-vector2)) derivations))
         (values (lambda (,particle)
                   (let ((,generated (funcall ,generator ,particle)))
                     ,@(mapcar (lambda (function derivation)
                                 (etypecase function
                                   (number `(raylib:%vector2-scale (& ,derivation) (& ,generated) ,(coerce function 'single-float)))
                                   ((or list symbol) `(funcall ,function ,derivation ,generated))))
                               functions derivations)
                     ,generated))
                 . ,(mapcar (lambda (derivation)
                              `(lambda (,particle)
                                 (declare (ignore ,particle))
                                 ,derivation))
                            derivations))))))

(declaim (inline %billboard-right-vector))
(defun %billboard-right-vector (right camera)
  (clet ((matview (foreign-alloca '(:struct raylib:matrix))))
    (declare (ctype (:pointer (:struct raylib:vector3)) right)
             (ctype (:pointer (:struct raylib:camera-3d)) camera))
    (raylib:%matrix-look-at matview (& (-> camera raylib:position)) (& (-> camera raylib:target)) (& (-> camera raylib:up)))
    (setf (-> right raylib:x) (-> matview raylib:m0)
          (-> right raylib:y) (-> matview raylib:m4)
          (-> right raylib:z) (-> matview raylib:m8))))

(declaim (ftype (function ((particle-3d-value-or-generator raylib:camera-3d)
                           (particle-3d-value-or-generator raylib:vector3)
                           &key
                           (:acceleration (particle-3d-value-or-generator raylib:vector2))
                           (:velocity (particle-3d-value-or-generator raylib:vector2))
                           (:position (particle-3d-value-or-generator raylib:vector2))
                           (:up (particle-3d-value-or-generator raylib:vector3))
                           (:lifetime (particle-3d-value-or-generator single-float)))
                          (values particle-3d-updater))
                particle-3d-billboard-updater))
(defun particle-3d-billboard-updater (camera origin
                                      &key
                                        (acceleration (raylib:make-vector2 :x 0.0 :y 0.0))
                                        (velocity (make-particle-3d-vector2-generator 10.0))
                                        (position (raylib:make-vector2 :x 0.0 :y 0.0))
                                        (up (raylib:make-vector3 :x 0.0 :y 1.0 :z 0.0))
                                        (lifetime 1.0))
  (with-value-generators (acceleration velocity origin position up camera lifetime)
    (declare (type (function (particle-3d) (values single-float)) lifetime)
             (type (function (particle-3d) (values raylib:camera)) camera)
             (type (function (particle-3d) (values raylib:vector3)) origin up)
             (type (function (particle-3d) (values raylib:vector2)) position velocity acceleration))
    (lambda (particle)
      (if (zerop (particle-3d-age particle))
          (let ((camera (funcall camera particle))
                (origin (funcall origin particle))
                (position (funcall position particle))
                (up (funcall up particle))
                (velocity (funcall velocity particle))
                (acceleration (funcall acceleration particle))
                (lifetime (funcall lifetime particle)))
            (declare (type single-float lifetime))
            (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
                   (camera (cthe (:pointer (:struct raylib:camera-3d)) (& camera)))
                   (origin (cthe (:pointer (:struct raylib:vector3)) (& origin)))
                   (up (cthe (:pointer (:struct raylib:vector3)) (& up)))
                   (position (cthe (:pointer (:struct raylib:vector3)) (& position)))
                   (velocity (cthe (:pointer (:struct raylib:vector2)) (& velocity)))
                   (acceleration (cthe (:pointer (:struct raylib:vector2)) (& acceleration)))
                   (axis (foreign-alloca '(:struct raylib:vector3)))
                   (direction (foreign-alloca '(:struct raylib:vector3))))
              (%billboard-right-vector direction camera)
              (raylib:%vector3-cross-product axis direction up)
              (raylib:%vector3-normalize direction direction)
              (clet ((particle-velocity (& (-> particle position-velocity))))
                (raylib:%vector3-rotate-by-axis-angle particle-velocity direction axis (raylib:atan2f (-> velocity raylib:y) (-> velocity raylib:x)))
                (raylib:%vector3-scale particle-velocity particle-velocity (raylib:%vector2-length velocity)))
              (clet ((particle-acceleration (& (-> particle position-acceleration))))
                (raylib:%vector3-rotate-by-axis-angle particle-acceleration direction axis (raylib:atan2f (-> acceleration raylib:y) (-> acceleration raylib:x)))
                (raylib:%vector3-scale particle-acceleration particle-acceleration (raylib:%vector2-length acceleration)))
              (clet ((particle-position (& (-> particle position))))
                (csetf ([] particle-position) ([] origin))
                (raylib:%vector3-scale direction direction (-> position raylib:x))
                (raylib:%vector3-add particle-position particle-position direction)
                (raylib:%vector3-scale direction up (-> position raylib:y))
                (raylib:%vector3-add particle-position particle-position direction))
              (raylib:%quaternion-identity (& (-> particle rotation)))
              (raylib:%quaternion-identity (& (-> particle rotation-velocity)))
              (raylib:%quaternion-identity (& (-> particle rotation-acceleration)))
              (setf (-> particle lifetime) lifetime)))
          (particle-3d-update-motion particle)))))

(declaim (ftype (function (single-float single-float single-float) (values single-float)) uniformly-varied-linear-motion-time))
(defun uniformly-varied-linear-motion-time (v a s)
  (if (zerop a)
      (/ s v)
      (let ((a (* 0.5 a)) (b v) (c (- s)))
        (declare (type single-float a b c))
        (let ((delta (- (* b b) (* 4.0 a c))))
          (declare (type (single-float 0.0) delta))
          (/ (- (sqrt delta) b) (* 2.0 a))))))

(declaim (ftype (function ((particle-3d-value-or-generator raylib:vector3)
                           (particle-3d-value-or-generator raylib:vector3)
                           &key
                           (:normal-velocity (particle-3d-value-or-generator raylib:vector2))
                           (:normal-offset (particle-3d-value-or-generator raylib:vector2))
                           (:axial-velocity (particle-3d-value-or-generator single-float))
                           (:axial-acceleration (particle-3d-value-or-generator single-float)))
                          (values particle-3d-updater))
                particle-3d-laser-updater))
(defun particle-3d-laser-updater (origin target
                                  &key
                                    (normal-velocity (make-particle-3d-vector2-generator 10.0))
                                    (normal-offset +vector2-zeros+)
                                    (axial-velocity 10.0)
                                    (axial-acceleration 5.0))
  (with-value-generators (axial-velocity axial-acceleration normal-velocity normal-offset origin target)
    (declare (type (function (particle-3d) (values single-float)) axial-velocity axial-acceleration)
             (type (function (particle-3d) (values raylib:vector3)) origin target)
             (type (function (particle-3d) (values raylib:vector2)) normal-velocity normal-offset))
    (clet ((axis-x (cthe (:pointer (:struct raylib:vector3)) (& +vector3-unit-x+)))
           (axis-y (cthe (:pointer (:struct raylib:vector3)) (& +vector3-unit-y+))))
      (lambda (particle)
        (if (zerop (particle-3d-age particle))
            (let ((origin (funcall origin particle))
                  (target (funcall target particle))
                  (normal-offset (funcall normal-offset particle))
                  (normal-velocity (funcall normal-velocity particle))
                  (axial-velocity (funcall axial-velocity particle))
                  (axial-acceleration (funcall axial-acceleration particle)))
              (declare (type single-float axial-velocity axial-acceleration))
              (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
                     (origin (cthe (:pointer (:struct raylib:vector3)) (& origin)))
                     (target (cthe (:pointer (:struct raylib:vector3)) (& target)))
                     (normal-velocity (cthe (:pointer (:struct raylib:vector2)) (& normal-velocity)))
                     (normal-offset (cthe (:pointer (:struct raylib:vector2)) (& normal-offset)))
                     (propagation (foreign-alloca '(:struct raylib:vector3)))
                     (right (foreign-alloca '(:struct raylib:vector3)))
                     (up (foreign-alloca '(:struct raylib:vector3))))
                (raylib:%vector3-subtract propagation target origin)
                (let ((lifetime (uniformly-varied-linear-motion-time axial-velocity axial-acceleration (raylib:%vector3-length propagation))))
                  (declare (type single-float lifetime))
                  (raylib:%vector3-cross-product right propagation axis-y)
                  (when (zerop (raylib:%vector3-length right))
                    (csetf ([] right) ([] axis-x)))
                  (raylib:%vector3-cross-product up right propagation)
                  (raylib:%vector3-normalize right right)
                  (raylib:%vector3-normalize up up)
                  (raylib:%vector3-scale right right (-> normal-velocity raylib:x))
                  (raylib:%vector3-scale up up (-> normal-velocity raylib:y))
                  (raylib:%vector3-add up up right) ; normal-velocity
                  (clet ((velocity (& (-> particle position-velocity))))
                    (raylib:%vector3-normalize velocity propagation)
                    (raylib:%vector3-scale velocity velocity axial-velocity) ; axial-velocity
                    (raylib:%vector3-add velocity velocity up))
                  (raylib:%vector3-scale up up (/ -2.0 lifetime)) ; normal-acceleration
                  (clet ((acceleration (& (-> particle position-acceleration))))
                    (raylib:%vector3-normalize acceleration propagation)
                    (raylib:%vector3-scale acceleration acceleration axial-acceleration) ; axial-acceleration
                    (raylib:%vector3-add acceleration acceleration up))
                  (raylib:%vector3-cross-product right propagation axis-y)
                  (when (zerop (raylib:%vector3-length right))
                    (csetf ([] right) ([] axis-x)))
                  (raylib:%vector3-cross-product up propagation right)
                  (raylib:%vector3-normalize right right)
                  (raylib:%vector3-normalize up up)
                  (raylib:%vector3-scale right right (-> normal-offset raylib:x))
                  (raylib:%vector3-scale up up (-> normal-offset raylib:y))
                  (raylib:%vector3-add up up right)
                  (raylib:%vector3-add (& (-> particle position)) origin up)
                  (raylib:%quaternion-identity (& (-> particle rotation)))
                  (raylib:%quaternion-identity (& (-> particle rotation-velocity)))
                  (raylib:%quaternion-identity (& (-> particle rotation-acceleration)))
                  (setf (-> particle lifetime) lifetime))))
            (particle-3d-update-motion particle))))))

(declaim (ftype (function (raylib:color &optional raylib:color (function (single-float) (values single-float)))
                          (values (function (particle-3d) (values raylib:color))))
                particle-3d-interpolate-color-over-age))
(defun particle-3d-interpolate-color-over-age (start
                                               &optional
                                                 (end (raylib:fade start 0.0))
                                                 (ease #'ute:linear-inout))
  (let ((color (raylib:make-color)))
    (lambda (particle &aux (amount (funcall ease (particle-3d-age particle))))
      (setf (raylib:color-r color) (floor (lerp amount (coerce (raylib:color-r start) 'single-float)
                                                (coerce (raylib:color-r end) 'single-float)))
            (raylib:color-g color) (floor (lerp amount (coerce (raylib:color-g start) 'single-float)
                                                (coerce (raylib:color-g end) 'single-float)))
            (raylib:color-b color) (floor (lerp amount (coerce (raylib:color-b start) 'single-float)
                                                (coerce (raylib:color-b end) 'single-float)))
            (raylib:color-a color) (floor (lerp amount (coerce (raylib:color-a start) 'single-float)
                                                (coerce (raylib:color-a end) 'single-float))))
      color)))

(declaim (ftype (function (raylib:vector3 &optional raylib:vector3 (function (single-float) (values single-float)))
                          (values (function (particle-3d) (values raylib:vector3))))
                particle-3d-interpolate-vector3-over-age))
(defun particle-3d-interpolate-vector3-over-age (start &optional (end +vector3-zeros+) (ease #'ute:linear-inout))
  (let ((vector3 (raylib:make-vector3)))
    (lambda (particle &aux (amount (funcall ease (particle-3d-age particle))))
      (raylib:%vector3-lerp (& vector3) (& start) (& end) amount)
      vector3)))

(declaim (ftype (function (sequence &optional single-float (function (single-float) (values single-float)))
                          (values (function (particle-3d) (values t))))
                particle-3d-iterate-sequence-over-age))
(defun particle-3d-iterate-sequence-over-age (sequence &optional (speed 1.0) (ease #'ute:linear-inout))
  (let ((length (length sequence)))
    (lambda (particle &aux (amount (funcall ease (particle-3d-age particle))))
      (elt sequence (mod (floor (* amount length speed)) length)))))

(declaim (ftype (function (&optional raylib:vector4 raylib:vector4 (function (single-float) (values single-float)))
                          (values (function (particle-3d) (values raylib:vector3))))
                particle-3d-interpolate-quaternion-over-age))
(defun particle-3d-interpolate-quaternion-over-age (&optional
                                                      (start (raylib:quaternion-from-euler 0.0 0.0 0.0))
                                                      (end (raylib:make-quaternion :x 0.0 :y 0.0 :z 1.0 :w 0.0))
                                                      (ease #'ute:linear-inout))
  (let ((quaternion (raylib:make-quaternion)))
    (lambda (particle &aux (amount (funcall ease (particle-3d-age particle))))
      (raylib:%quaternion-slerp (& quaternion) (& start) (& end) amount)
      quaternion)))

(declaim (ftype (function (&optional (particle-3d-value-or-generator single-float)
                                     (particle-3d-value-or-generator raylib:color))
                          (values particle-3d-renderer))
                particle-3d-cube-renderer))
(defun particle-3d-cube-renderer (&optional (size 0.5) (color (particle-3d-interpolate-color-over-age raylib:+red+)))
  (with-value-generators (color)
    (declare (type (function (particle-3d) (values raylib:color)) color))
    (lambda (particle)
      (let ((color (funcall color particle)))
        (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
               (color (cthe (:pointer (:struct raylib:color)) (& color))))
          (raylib:%draw-cube (& (-> particle position)) size size size color))))))

(declaim (ftype (function (&optional (particle-3d-value-or-generator single-float)
                                     (particle-3d-value-or-generator raylib:color))
                          (values particle-3d-renderer))
                particle-3d-sphere-renderer))
(defun particle-3d-sphere-renderer (&optional (size 0.25) (color (particle-3d-interpolate-color-over-age raylib:+red+)))
  (with-value-generators (color)
    (declare (type (function (particle-3d) (values raylib:color)) color))
    (lambda (particle)
      (let ((color (funcall color particle)))
        (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
               (color (cthe (:pointer (:struct raylib:color)) (& color))))
          (raylib:%draw-sphere (& (-> particle position)) size color))))))

(declaim (ftype (function ((particle-3d-value-or-generator raylib:vector3)
                           (particle-3d-value-or-generator raylib:vector3)
                           &key
                           (:angular-velocity (particle-3d-value-or-generator single-float))
                           (:axial-velocity (particle-3d-value-or-generator single-float))
                           (:axial-acceleration (particle-3d-value-or-generator single-float))
                           (:radius (particle-3d-value-or-generator single-float))
                           (:initial-phase (particle-3d-value-or-generator single-float)))
                          (values particle-3d-updater))
                particle-3d-spiral-updater))
(defun particle-3d-spiral-updater (origin target
                                   &key
                                     (angular-velocity (* (coerce pi 'single-float) 2.0))
                                     (axial-velocity 1.0)
                                     (axial-acceleration 0.0)
                                     (radius 1.0) (initial-phase 0.0))
  (with-value-generators (axial-velocity axial-acceleration angular-velocity origin target radius initial-phase)
    (declare (type (function (particle-3d) (values single-float)) axial-velocity axial-acceleration angular-velocity initial-phase)
             (type (function (particle-3d) (values single-float)) radius)
             (type (function (particle-3d) (values raylib:vector3)) origin target))
    (let ((particle-ages (make-hash-table)))
      (clet ((axis-x (cthe (:pointer (:struct raylib:vector3)) (& +vector3-unit-x+))))
        (lambda (particle)
          (if (zerop (particle-3d-age particle))
              (let ((origin (funcall origin particle))
                    (target (funcall target particle))
                    (angular-velocity (funcall angular-velocity particle))
                    (axial-velocity (funcall axial-velocity particle))
                    (axial-acceleration (funcall axial-acceleration particle)))
                (clet ((propagation (foreign-alloca '(:struct raylib:vector3)))
                       (origin (cthe (:pointer (:struct raylib:vector3)) (& origin)))
                       (target (cthe (:pointer (:struct raylib:vector3)) (& target))))
                  (raylib:%vector3-subtract propagation target origin)
                  (setf (particle-3d-lifetime particle) (uniformly-varied-linear-motion-time
                                                         axial-velocity axial-acceleration
                                                         (raylib:%vector3-length propagation)))
                  (let ((radius (funcall radius particle)) (initial-phase (funcall initial-phase particle)))
                    (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle))))
                      (raylib:%vector3-cross-product (& (-> particle position-velocity)) propagation axis-x)
                      (raylib:%vector3-rotate-by-axis-angle (& (-> particle position-velocity)) (& (-> particle position-velocity)) propagation initial-phase)
                      (raylib:%vector3-cross-product (& (-> particle position)) (& (-> particle position-velocity)) propagation)
                      (raylib:%vector3-normalize (& (-> particle position-velocity)) (& (-> particle position-velocity)))
                      (raylib:%vector3-scale (& (-> particle position-velocity)) (& (-> particle position-velocity)) (* angular-velocity radius))
                      
                      (raylib:%vector3-normalize (& (-> particle position-acceleration)) propagation)
                      (raylib:%vector3-scale (& (-> particle position-acceleration)) (& (-> particle position-acceleration)) axial-velocity)
                      (raylib:%vector3-add (& (-> particle position-velocity)) (& (-> particle position-velocity)) (& (-> particle position-acceleration)))
                      (raylib:%vector3-normalize (& (-> particle position-acceleration)) propagation)
                      (raylib:%vector3-scale (& (-> particle position-acceleration)) (& (-> particle position-acceleration)) axial-acceleration)
                      
                      (raylib:%vector3-normalize (& (-> particle position)) (& (-> particle position)))
                      (raylib:%vector3-scale (& (-> particle position)) (& (-> particle position)) radius)
                      (raylib:%vector3-add (& (-> particle position)) origin (& (-> particle position)))
                      (raylib:%quaternion-identity (& (-> particle rotation)))
                      (raylib:%quaternion-identity (& (-> particle rotation-velocity)))
                      (raylib:%quaternion-identity (& (-> particle rotation-acceleration)))))))
              (let ((origin (funcall origin particle)) (target (funcall target particle))
                    (angular-velocity (funcall angular-velocity particle))
                    (radius (funcall radius particle))
                    (delta (let* ((age (particle-3d-age particle))
                                  (previous-age (ensure-gethash particle particle-ages 0.0)))
                             (declare (type single-float age previous-age))
                             (prog1 (* (- age (if (< previous-age age) previous-age 0.0)) (particle-3d-lifetime particle))
                               (setf (gethash particle particle-ages) age)))))
                (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
                       (propagation (foreign-alloca '(:struct raylib:vector3)))
                       (origin (cthe (:pointer (:struct raylib:vector3)) (& origin)))
                       (target (cthe (:pointer (:struct raylib:vector3)) (& target))))
                  (raylib:%vector3-subtract propagation target origin)
                  (raylib:%vector3-rotate-by-axis-angle (& (-> particle position-velocity)) (& (-> particle position-velocity)) propagation (* angular-velocity delta))
                  (let* ((previous-radius (/ (raylib:%vector3-length (& (-> particle position-velocity))) (abs angular-velocity)))
                         (tangential-velocity-scale (/ radius previous-radius)))
                    (raylib:%vector3-normalize propagation propagation)
                    (raylib:%vector3-scale propagation propagation (raylib:%vector3-dot-product propagation (& (-> particle position-velocity))))
                    (raylib:%vector3-subtract (& (-> particle position-velocity)) (& (-> particle position-velocity)) propagation)
                    (raylib:%vector3-scale (& (-> particle position-velocity)) (& (-> particle position-velocity)) tangential-velocity-scale)
                    (raylib:%vector3-add (& (-> particle position-velocity)) (& (-> particle position-velocity)) propagation)))
                (particle-3d-update-motion particle))))))))
