(in-package #:eon)

(defcstruct particle-3d
  (position (:struct raylib:vector3))
  (position-velocity (:struct raylib:vector3))
  (position-acceleration (:struct raylib:vector3))
  (rotation (:struct raylib:vector4))
  (rotation-velocity (:struct raylib:vector4))
  (rotation-acceleration (:struct raylib:vector4))
  (age :float)
  (lifetime :float)
  (livep :boolean))

(cobj:define-cobject-class (:struct particle-3d))

(declaim (inline particle-3d-velocity))
(defun particle-3d-velocity (instance)
  (particle-3d-position-velocity instance))

(declaim (inline (setf particle-3d-velocity)))
(defun (setf particle-3d-velocity) (value instance)
  (setf (particle-3d-position-velocity instance) value))

(declaim (inline particle-3d-acceleration))
(defun particle-3d-acceleration (instance)
  (particle-3d-position-acceleration instance))

(declaim (inline (setf particle-3d-acceleration)))
(defun (setf particle-3d-acceleration) (value instance)
  (setf (particle-3d-position-acceleration instance) value))

(deftype particle-3d-updater ()
  "A function taking a PARTICLE-3D as parameter. When a particle is activated, UPDATER is called once on it, with the particle's PARTICLE-3D-AGE set to 0.0, and UPDATER should set the initial motion state for the particle. During each subsequent frame, when updating a live particle, UPDATER is called again on it, with the particle's PARTICLE-3D-AGE greater than 0.0, and UPDATER should update the particle's motion state from its current state to the next state."
  '(function (particle-3d)))

(defconstant +particle-3d-emitter-default-capacity+ 128)

(defstruct (particle-3d-emitter (:constructor %make-particle-3d-emitter))
  "A 3D particle emitter, composed of particles and the logic to initialize and update them."
  (particles nil :type (simple-array particle-3d (*)))
  (updater #'values :type particle-3d-updater))

(declaim (ftype (function (&key (:capacity positive-fixnum) (:updater particle-3d-updater)) (values particle-3d-emitter)) make-particle-3d-emitter))
(defun make-particle-3d-emitter (&key (capacity +particle-3d-emitter-default-capacity+) (updater #'values))
  "Create a PARTICLE-3D-EMITTER with CAPACITY. It uses UPDATER of type PARTICLE-3D-UPDATER to initialize and update the motion state of particles."
  (loop :with particles :of-type (simple-array particle-3d (*)) := (cobj:ccoerce (cobj:make-carray capacity :element-type 'particle-3d) 'simple-array)
        :for particle :across particles
        :do (setf (particle-3d-livep particle) nil)
        :finally (return (%make-particle-3d-emitter :particles particles :updater updater))))

(deftype particle-3d-renderer ()
  "A function taking a PARTICLE-3D as tha parameter, used in PARTICLE-3D-EMITTER-DRAW to render particles."
  '(function (particle-3d)))

(declaim (ftype (function (particle-3d-emitter non-negative-fixnum) (values boolean)) particle-3d-emitter-emit))
(defun particle-3d-emitter-emit (emitter count)
  "Make the EMITTER emit COUNT particles if there is enough capacity available."
  (loop :with particles :of-type (simple-array particle-3d (*)) := (particle-3d-emitter-particles emitter)
        :for particle :across particles
        :when (>= emitted count)
          :return t
        :unless (particle-3d-livep particle)
          :do (setf (particle-3d-age particle) 0.0
                    (particle-3d-livep particle) t)
          :and :count 1 :into emitted :of-type non-negative-fixnum))

(declaim (ftype (function (foreign-pointer foreign-pointer single-float) (values foreign-pointer)) %quaternion-scale-rotation)
         (inline %quaternion-scale-rotation))
(defun %quaternion-scale-rotation (result quaternion value)
  (clet* ((axis+angle (foreign-alloca '(:struct raylib:vector4)))
          (axis (cthe (:pointer (:struct raylib:vector3)) axis+angle))
          (angle (cthe (:pointer :float) (& (-> axis+angle raylib:w)))))
    (raylib:%quaternion-to-axis-angle quaternion axis angle)
    (raylib:%quaternion-from-axis-angle result axis (* ([] angle) value))
    result))

(defun particle-3d-initialize-default (particle &optional position)
  "Initialize the motion state of PARTICLE at POSITION to their default values."
  (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle))))
    (if position
        (csetf (-> particle position) ([] (cthe (:pointer (:struct raylib:vector3)) (& position))))
        (raylib:%vector3-zero (& (-> particle position))))
    (raylib:%vector3-zero (& (-> particle position-velocity)))
    (raylib:%vector3-zero (& (-> particle position-acceleration)))
    (raylib:%quaternion-identity (& (-> particle rotation)))
    (raylib:%quaternion-identity (& (-> particle rotation-velocity)))
    (raylib:%quaternion-identity (& (-> particle rotation-acceleration)))
    (setf (-> particle age) 0.0 (-> particle lifetime) 1.0)))

(defun particle-3d-update-motion (particle &optional (delta (locally (declare (special #1=particle-3d-delta-time)) #1#)))
  "Update the motion state of PARTICLE using interval time DELTA."
  (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
         (s (foreign-alloca '(:struct raylib:vector4))))
    (clet ((p (& (-> particle position)))
           (a (& (-> particle position-acceleration)))
           (v (& (-> particle position-velocity))))
      (raylib:%vector3-scale s a delta)
      (raylib:%vector3-add v s v)
      (raylib:%vector3-scale s s 0.5)
      (raylib:%vector3-subtract s v s)
      (raylib:%vector3-scale s s delta)
      (raylib:%vector3-add p p s))
    (clet ((p (& (-> particle rotation)))
           (a (& (-> particle rotation-acceleration)))
           (v (& (-> particle rotation-velocity))))
      (%quaternion-scale-rotation s a delta)
      (raylib:%quaternion-multiply v s v)
      (%quaternion-scale-rotation s s 0.5)
      (raylib:%quaternion-invert s s)
      (raylib:%quaternion-multiply s v s)
      (%quaternion-scale-rotation s s delta)
      (raylib:%quaternion-multiply p p s)
      nil)))

(declaim (ftype (function (particle-3d-emitter &optional single-float)) particle-3d-emitter-update))
(defun particle-3d-emitter-update (emitter &optional (delta (game-loop-delta-time)) &aux (particle-3d-delta-time delta))
  "Update all particles of EMITTER with interval time DELTA."
  (declare (special particle-3d-delta-time))
  (loop :with particles :of-type (simple-array particle-3d (*)) := (particle-3d-emitter-particles emitter)
        :and updater :of-type (function (particle-3d)) := (particle-3d-emitter-updater emitter)
        :for particle :across particles
        :do (when (particle-3d-livep particle)
              (if (zerop (particle-3d-age particle))
                  (progn
                    (funcall updater particle)
                    (incf (particle-3d-age particle) single-float-epsilon))
                  (incf (particle-3d-age particle) (/ delta (particle-3d-lifetime particle))))
              (if (> (particle-3d-age particle) 1.0)
                  (setf (particle-3d-livep particle) nil)
                  (funcall updater particle)))))

(declaim (ftype (function (particle-3d-emitter particle-3d-renderer)) particle-3d-emitter-draw))
(defun particle-3d-emitter-draw (emitter renderer)
  "Use RENDERER of type PARTICLE-3D-RENDERER to draw all particles of EMITTER."
  (loop :with particles :of-type (simple-array particle-3d (*)) := (particle-3d-emitter-particles emitter)
        :for particle :across particles
        :when (particle-3d-livep particle)
          :do (funcall renderer particle)))

(declaim (ftype (function (particle-3d-emitter
                           (function (single-float) single-float)
                           particle-3d-renderer
                           &optional (function () (values single-float)))
                          (function (&optional single-float)))
                particle-3d-emitter-emit-update-draw-function))
(defun particle-3d-emitter-emit-update-draw-function (emitter rate-function renderer &optional (delta #'game-loop-delta-time))
  "Return a function that can update EMITTER and draw its particles using RENDERER of type PARTICLE-3D-RENDERER, while utilizing the time interval returned by function DELTA. RATE-FUNCTION is a function that takes a SINGLE-FLOAT type update time interval and returns a SINGLE-FLOAT type representing the number of particles to emit within that time interval. This allows EMITTER to automatically emit particles during the update process without the need to manually call PARTICLE-3D-EMITTER-EMIT. The returned function can optionally accept a time interval as a parameter to replace the result of function DELTA for updating and emitting particles."
  (let ((rate-fraction 0.0))
    (declare (type single-float rate-fraction))
    (lambda (&optional (delta (funcall delta)))
      (declare (type single-float delta))
      (particle-3d-emitter-emit emitter (multiple-value-bind (count fraction) (truncate (+ (funcall rate-function delta) rate-fraction))
                                          (declare (type non-negative-fixnum count)
                                                   (type single-float fraction))
                                          (setf rate-fraction fraction)
                                          count))
      (particle-3d-emitter-update emitter delta)
      (particle-3d-emitter-draw emitter renderer))))

(declaim (ftype (function (t) (values function)) ensure-value-generator))
(defun ensure-value-generator (value)
  (if (functionp value) value (constantly value)))

(defmacro with-value-generators (values &body body)
  `(let ,(mapcar (lambda (value) `(,value (ensure-value-generator ,value))) values)
     (declare (type function . ,values))
     . ,body))

(deftype particle-3d-value-generator (type)
  "A function that accepts a PARTICLE-3D as the parameter and returns a random value."
  `(function (particle-3d) (values ,type)))

(deftype particle-3d-value-or-generator (type)
  `(or (particle-3d-value-generator ,type) ,type))

(cobj:define-global-cobject +vector2-zeros+ (raylib:make-vector2 :x 0.0 :y 0.0))
(cobj:define-global-cobject +vector3-unit-x+ (raylib:make-vector3 :x 1.0 :y 0.0 :z 0.0))
(cobj:define-global-cobject +vector3-unit-y+ (raylib:make-vector3 :x 0.0 :y 1.0 :z 0.0))
(cobj:define-global-cobject +vector3-zeros+ (raylib:make-vector3 :x 0.0 :y 0.0 :z 0.0))

(defun make-particle-3d-vector2-generator (length)
  "Return a PARTICLE-3D-VALUE-GENERATOR of RAYLIB:VECTOR2. The LENGTH can have the following types:
- SINGLE-FLOAT: The returned generator will randomly generate a RAYLIB:VECTOR2 with a length of LENGTH.
- (CONS SINGLE-FLOAT SINGLE-FLOAT): The returned generator will randomly generate a RAYLIB:VECTOR2 with a length between (CAR LENGTH) and (CDR LENGTH).
- RAYLIB:VECTOR2: The returned generator will randomly generate a RAYLIB:VECTOR2 where the absolute values of its two components are less than (RAYLIB:VECTOR2-X LENGTH) and (RAYLIB:VECTOR2-Y LENGTH)."
  (etypecase length
    (single-float
     (let ((v (raylib:make-vector2 :x length :y 0.0)))
       (lambda (particle)
         (declare (ignore particle))
         (raylib:%vector2-rotate (& v) (& v) (random (coerce (* pi 2.0) 'single-float))) v)))
    ((cons single-float single-float)
     (let ((v (raylib:make-vector2 :x (car length) :y 0.0)))
       (lambda (particle)
         (declare (ignore particle))
         (raylib:%vector2-normalize (& v) (& v))
         (raylib:%vector2-scale (& v) (& v) (+ (random (- (cdr length) (car length))) (car length)))
         (raylib:%vector2-rotate (& v) (& v) (random (coerce (* pi 2.0) 'single-float)))
         v)))
    (raylib:vector2
     (let ((v (raylib:make-vector2)))
       (lambda (particle &aux (range-x (raylib:vector2-x length)) (range-y (raylib:vector2-y length)))
         (declare (ignore particle))
         (setf (raylib:vector2-x v) (if (plusp range-x) (- (random (* 2.0 range-x)) range-x) 0.0)
               (raylib:vector2-y v) (if (plusp range-y) (- (random (* 2.0 range-y)) range-y) 0.0))
         v)))))

(defmacro derive-particle-3d-vector2-generator (generator-form &rest functions)
  "A macro that accepts a PARTICLE-3D-VALUE-GENERATOR of type RAYLIB:VECTOR2 as its first parameter with remaining parameters to create more PARTICLE-3D-VALUE-GENERATORs based on it, and returns multiple generators represented by all the parameters. Only after the given generator generates a new value, can the remaining generators return new values. Each remaining parameter can have the following types:
- NUMBER: Used to scale the RAYLIB:VECTOR2 generated by the given generator.
- FUNCTION: Used to transform the RAYLIB:VECTOR2 generated by the given generator arbitrarily."
  (with-gensyms (generator generated particle)
    (let ((derivations (make-gensym-list (length functions) 'derivation)))
      `(let ((,generator ,generator-form)
             . ,(mapcar (rcurry #'list `(raylib:make-vector2)) derivations))
         (values (lambda (,particle)
                   (let ((,generated (funcall ,generator ,particle)))
                     ,@(mapcar (lambda (function derivation)
                                 (etypecase function
                                   (number `(raylib:%vector2-scale (& ,derivation) (& ,generated) ,(coerce function 'single-float)))
                                   ((or list symbol) `(funcall ,function ,derivation ,generated))))
                               functions derivations)
                     ,generated))
                 . ,(mapcar (lambda (derivation)
                              `(lambda (,particle)
                                 (declare (ignore ,particle))
                                 ,derivation))
                            derivations))))))

(declaim (inline %billboard-right-vector))
(defun %billboard-right-vector (right camera)
  (clet ((matview (foreign-alloca '(:struct raylib:matrix))))
    (declare (ctype (:pointer (:struct raylib:vector3)) right)
             (ctype (:pointer (:struct raylib:camera-3d)) camera))
    (raylib:%matrix-look-at matview (& (-> camera raylib:position)) (& (-> camera raylib:target)) (& (-> camera raylib:up)))
    (setf (-> right raylib:x) (-> matview raylib:m0)
          (-> right raylib:y) (-> matview raylib:m4)
          (-> right raylib:z) (-> matview raylib:m8))))

(declaim (ftype (function ((particle-3d-value-or-generator raylib:camera-3d)
                           (particle-3d-value-or-generator raylib:vector3)
                           &key
                           (:acceleration (particle-3d-value-or-generator raylib:vector2))
                           (:velocity (particle-3d-value-or-generator raylib:vector2))
                           (:position (particle-3d-value-or-generator raylib:vector2))
                           (:up (particle-3d-value-or-generator raylib:vector3))
                           (:lifetime (particle-3d-value-or-generator single-float)))
                          (values particle-3d-updater))
                particle-3d-billboard-updater))
(defun particle-3d-billboard-updater (camera origin
                                      &key
                                        (acceleration (raylib:make-vector2 :x 0.0 :y 0.0))
                                        (velocity (make-particle-3d-vector2-generator 10.0))
                                        (position (raylib:make-vector2 :x 0.0 :y 0.0))
                                        (up (raylib:make-vector3 :x 0.0 :y 1.0 :z 0.0))
                                        (lifetime 1.0))
  "A PARTICLE-3D-UPDATER that ensures particles always move on a plane facing CAMERA. The remaining parameters can be either a single value or a PARTICLE-3D-VALUE-GENERATOR of the value type. The origin of this plane will be set at ORIGIN in 3D space, with the upward direction defined by UP. The position, velocity, acceleration, and lifetime of the particle on the plane will be generated respectively by POSITION, VELOCITY, ACCELERATION, and LIFETIME."
  (with-value-generators (acceleration velocity origin position up camera lifetime)
    (declare (type (function (particle-3d) (values single-float)) lifetime)
             (type (function (particle-3d) (values raylib:camera)) camera)
             (type (function (particle-3d) (values raylib:vector3)) origin up)
             (type (function (particle-3d) (values raylib:vector2)) position velocity acceleration))
    (lambda (particle)
      (if (zerop (particle-3d-age particle))
          (let ((camera (funcall camera particle))
                (origin (funcall origin particle))
                (position (funcall position particle))
                (up (funcall up particle))
                (velocity (funcall velocity particle))
                (acceleration (funcall acceleration particle))
                (lifetime (funcall lifetime particle)))
            (declare (type single-float lifetime))
            (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
                   (camera (cthe (:pointer (:struct raylib:camera-3d)) (& camera)))
                   (origin (cthe (:pointer (:struct raylib:vector3)) (& origin)))
                   (up (cthe (:pointer (:struct raylib:vector3)) (& up)))
                   (position (cthe (:pointer (:struct raylib:vector3)) (& position)))
                   (velocity (cthe (:pointer (:struct raylib:vector2)) (& velocity)))
                   (acceleration (cthe (:pointer (:struct raylib:vector2)) (& acceleration)))
                   (axis (foreign-alloca '(:struct raylib:vector3)))
                   (direction (foreign-alloca '(:struct raylib:vector3))))
              (%billboard-right-vector direction camera)
              (raylib:%vector3-cross-product axis direction up)
              (raylib:%vector3-normalize direction direction)
              (clet ((particle-velocity (& (-> particle position-velocity))))
                (raylib:%vector3-rotate-by-axis-angle particle-velocity direction axis (raylib:atan2f (-> velocity raylib:y) (-> velocity raylib:x)))
                (raylib:%vector3-scale particle-velocity particle-velocity (raylib:%vector2-length velocity)))
              (clet ((particle-acceleration (& (-> particle position-acceleration))))
                (raylib:%vector3-rotate-by-axis-angle particle-acceleration direction axis (raylib:atan2f (-> acceleration raylib:y) (-> acceleration raylib:x)))
                (raylib:%vector3-scale particle-acceleration particle-acceleration (raylib:%vector2-length acceleration)))
              (clet ((particle-position (& (-> particle position))))
                (csetf ([] particle-position) ([] origin))
                (raylib:%vector3-scale direction direction (-> position raylib:x))
                (raylib:%vector3-add particle-position particle-position direction)
                (raylib:%vector3-scale direction up (-> position raylib:y))
                (raylib:%vector3-add particle-position particle-position direction))
              (raylib:%quaternion-identity (& (-> particle rotation)))
              (raylib:%quaternion-identity (& (-> particle rotation-velocity)))
              (raylib:%quaternion-identity (& (-> particle rotation-acceleration)))
              (setf (-> particle lifetime) lifetime)))
          (particle-3d-update-motion particle)))))

(declaim (ftype (function (single-float single-float single-float) (values single-float)) uniformly-varied-linear-motion-time))
(defun uniformly-varied-linear-motion-time (v a s)
  (if (zerop a)
      (/ s v)
      (let ((a (* 0.5 a)) (b v) (c (- s)))
        (declare (type single-float a b c))
        (let ((delta (- (* b b) (* 4.0 a c))))
          (declare (type (single-float 0.0) delta))
          (/ (- (sqrt delta) b) (* 2.0 a))))))

(declaim (ftype (function ((particle-3d-value-or-generator raylib:vector3)
                           (particle-3d-value-or-generator raylib:vector3)
                           &key
                           (:normal-velocity (particle-3d-value-or-generator raylib:vector2))
                           (:normal-offset (particle-3d-value-or-generator raylib:vector2))
                           (:axial-velocity (particle-3d-value-or-generator single-float))
                           (:axial-acceleration (particle-3d-value-or-generator single-float)))
                          (values particle-3d-updater))
                particle-3d-laser-updater))
(defun particle-3d-laser-updater (origin target
                                  &key
                                    (normal-velocity (make-particle-3d-vector2-generator 10.0))
                                    (normal-offset +vector2-zeros+)
                                    (axial-velocity 10.0)
                                    (axial-acceleration 5.0))
  "A PARTICLE-3D-UPDATER that initializes particles at ORIGIN and emits them towards TARGET. The particles' normal offset (perpendicular to the direction the particles are emitted) and velocity are generated by NORMAL-OFFSET and NORMAL-VELOCITY, respectively. The axial velocity and acceleration are generated by AXIAL-VELOCITY and AXIAL-ACCELERATION. The lifetime of the particles is automatically calculated based on the distance between ORIGIN and TARGET, as well as AXIAL-VELOCITY and AXIAL-ACCELERATION."
  (with-value-generators (axial-velocity axial-acceleration normal-velocity normal-offset origin target)
    (declare (type (function (particle-3d) (values single-float)) axial-velocity axial-acceleration)
             (type (function (particle-3d) (values raylib:vector3)) origin target)
             (type (function (particle-3d) (values raylib:vector2)) normal-velocity normal-offset))
    (clet ((axis-x (cthe (:pointer (:struct raylib:vector3)) (& +vector3-unit-x+)))
           (axis-y (cthe (:pointer (:struct raylib:vector3)) (& +vector3-unit-y+))))
      (lambda (particle)
        (if (zerop (particle-3d-age particle))
            (let ((origin (funcall origin particle))
                  (target (funcall target particle))
                  (normal-offset (funcall normal-offset particle))
                  (normal-velocity (funcall normal-velocity particle))
                  (axial-velocity (funcall axial-velocity particle))
                  (axial-acceleration (funcall axial-acceleration particle)))
              (declare (type single-float axial-velocity axial-acceleration))
              (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
                     (origin (cthe (:pointer (:struct raylib:vector3)) (& origin)))
                     (target (cthe (:pointer (:struct raylib:vector3)) (& target)))
                     (normal-velocity (cthe (:pointer (:struct raylib:vector2)) (& normal-velocity)))
                     (normal-offset (cthe (:pointer (:struct raylib:vector2)) (& normal-offset)))
                     (propagation (foreign-alloca '(:struct raylib:vector3)))
                     (right (foreign-alloca '(:struct raylib:vector3)))
                     (up (foreign-alloca '(:struct raylib:vector3))))
                (raylib:%vector3-subtract propagation target origin)
                (let ((lifetime (uniformly-varied-linear-motion-time axial-velocity axial-acceleration (raylib:%vector3-length propagation))))
                  (declare (type single-float lifetime))
                  (raylib:%vector3-cross-product right propagation axis-y)
                  (when (zerop (raylib:%vector3-length right))
                    (csetf ([] right) ([] axis-x)))
                  (raylib:%vector3-cross-product up right propagation)
                  (raylib:%vector3-normalize right right)
                  (raylib:%vector3-normalize up up)
                  (raylib:%vector3-scale right right (-> normal-velocity raylib:x))
                  (raylib:%vector3-scale up up (-> normal-velocity raylib:y))
                  (raylib:%vector3-add up up right) ; normal-velocity
                  (clet ((velocity (& (-> particle position-velocity))))
                    (raylib:%vector3-normalize velocity propagation)
                    (raylib:%vector3-scale velocity velocity axial-velocity) ; axial-velocity
                    (raylib:%vector3-add velocity velocity up))
                  (raylib:%vector3-scale up up (/ -2.0 lifetime)) ; normal-acceleration
                  (clet ((acceleration (& (-> particle position-acceleration))))
                    (raylib:%vector3-normalize acceleration propagation)
                    (raylib:%vector3-scale acceleration acceleration axial-acceleration) ; axial-acceleration
                    (raylib:%vector3-add acceleration acceleration up))
                  (raylib:%vector3-cross-product right propagation axis-y)
                  (when (zerop (raylib:%vector3-length right))
                    (csetf ([] right) ([] axis-x)))
                  (raylib:%vector3-cross-product up propagation right)
                  (raylib:%vector3-normalize right right)
                  (raylib:%vector3-normalize up up)
                  (raylib:%vector3-scale right right (-> normal-offset raylib:x))
                  (raylib:%vector3-scale up up (-> normal-offset raylib:y))
                  (raylib:%vector3-add up up right)
                  (raylib:%vector3-add (& (-> particle position)) origin up)
                  (raylib:%quaternion-identity (& (-> particle rotation)))
                  (raylib:%quaternion-identity (& (-> particle rotation-velocity)))
                  (raylib:%quaternion-identity (& (-> particle rotation-acceleration)))
                  (setf (-> particle lifetime) lifetime))))
            (particle-3d-update-motion particle))))))

(declaim (ftype (function (raylib:color &optional raylib:color (function (single-float) (values single-float)))
                          (values (function (particle-3d) (values raylib:color))))
                particle-3d-interpolate-color-over-age))
(defun particle-3d-interpolate-color-over-age (start
                                               &optional
                                                 (end (raylib:fade start 0.0))
                                                 (ease #'ute:linear-inout))
  "Return a PARTICLE-3D-VALUE-GENERATOR that generates a RAYLIB:COLOR interpolated between RAYLIB:COLORs START and END based on the particle's age using easing function EASE."
  (let ((color (raylib:make-color)))
    (lambda (particle &aux (amount (funcall ease (particle-3d-age particle))))
      (setf (raylib:color-r color) (floor (lerp amount (coerce (raylib:color-r start) 'single-float)
                                                (coerce (raylib:color-r end) 'single-float)))
            (raylib:color-g color) (floor (lerp amount (coerce (raylib:color-g start) 'single-float)
                                                (coerce (raylib:color-g end) 'single-float)))
            (raylib:color-b color) (floor (lerp amount (coerce (raylib:color-b start) 'single-float)
                                                (coerce (raylib:color-b end) 'single-float)))
            (raylib:color-a color) (floor (lerp amount (coerce (raylib:color-a start) 'single-float)
                                                (coerce (raylib:color-a end) 'single-float))))
      color)))

(declaim (ftype (function (raylib:vector3 &optional raylib:vector3 (function (single-float) (values single-float)))
                          (values (function (particle-3d) (values raylib:vector3))))
                particle-3d-interpolate-vector3-over-age))
(defun particle-3d-interpolate-vector3-over-age (start &optional (end +vector3-zeros+) (ease #'ute:linear-inout))
  "Return a PARTICLE-3D-VALUE-GENERATOR that generates a RAYLIB:VECTOR3 interpolated between RAYLIB:VECTOR3s START and END based on the particle's age using easing function EASE."
  (let ((vector3 (raylib:make-vector3)))
    (lambda (particle &aux (amount (funcall ease (particle-3d-age particle))))
      (raylib:%vector3-lerp (& vector3) (& start) (& end) amount)
      vector3)))

(declaim (ftype (function (sequence &optional single-float (function (single-float) (values single-float)))
                          (values (function (particle-3d) (values t))))
                particle-3d-iterate-sequence-over-age))
(defun particle-3d-iterate-sequence-over-age (sequence &optional (speed 1.0) (ease #'ute:linear-inout))
  "Return a PARTICLE-3D-VALUE-GENERATOR that traverses the elements of SEQUENCE at SPEED based on the particle's age and easing function EASE."
  (let ((length (length sequence)))
    (lambda (particle &aux (amount (funcall ease (particle-3d-age particle))))
      (elt sequence (mod (floor (* amount length speed)) length)))))

(declaim (ftype (function (&optional raylib:vector4 raylib:vector4 (function (single-float) (values single-float)))
                          (values (function (particle-3d) (values raylib:vector3))))
                particle-3d-interpolate-quaternion-over-age))
(defun particle-3d-interpolate-quaternion-over-age (&optional
                                                      (start (raylib:quaternion-from-euler 0.0 0.0 0.0))
                                                      (end (raylib:make-quaternion :x 0.0 :y 0.0 :z 1.0 :w 0.0))
                                                      (ease #'ute:linear-inout))
  "Return a PARTICLE-3D-VALUE-GENERATOR that generates a QUATERNION interpolated between QUATERNIONs START and END based on the particle's age using easing function EASE."
  (let ((quaternion (raylib:make-quaternion)))
    (lambda (particle &aux (amount (funcall ease (particle-3d-age particle))))
      (raylib:%quaternion-slerp (& quaternion) (& start) (& end) amount)
      quaternion)))

(declaim (ftype (function (&optional (particle-3d-value-or-generator single-float)
                                     (particle-3d-value-or-generator raylib:color))
                          (values particle-3d-renderer))
                particle-3d-cube-renderer))
(defun particle-3d-cube-renderer (&optional (size 0.5) (color (particle-3d-interpolate-color-over-age raylib:+red+)))
  "A PARTICLE-3D-RENDERER that renders particles as cubes with SIZE and COLOR."
  (with-value-generators (color)
    (declare (type (function (particle-3d) (values raylib:color)) color))
    (lambda (particle)
      (let ((color (funcall color particle)))
        (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
               (color (cthe (:pointer (:struct raylib:color)) (& color))))
          (raylib:%draw-cube (& (-> particle position)) size size size color))))))

(declaim (ftype (function (&optional (particle-3d-value-or-generator single-float)
                                     (particle-3d-value-or-generator raylib:color))
                          (values particle-3d-renderer))
                particle-3d-sphere-renderer))
(defun particle-3d-sphere-renderer (&optional (size 0.25) (color (particle-3d-interpolate-color-over-age raylib:+red+)))
  "A PARTICLE-3D-RENDERER that renders particles as spheres with SIZE and COLOR."
  (with-value-generators (color)
    (declare (type (function (particle-3d) (values raylib:color)) color))
    (lambda (particle)
      (let ((color (funcall color particle)))
        (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
               (color (cthe (:pointer (:struct raylib:color)) (& color))))
          (raylib:%draw-sphere (& (-> particle position)) size color))))))

(declaim (ftype (function ((particle-3d-value-or-generator raylib:vector3)
                           (particle-3d-value-or-generator raylib:vector3)
                           &key
                           (:angular-velocity (particle-3d-value-or-generator single-float))
                           (:axial-velocity (particle-3d-value-or-generator single-float))
                           (:axial-acceleration (particle-3d-value-or-generator single-float))
                           (:radius (particle-3d-value-or-generator single-float))
                           (:initial-phase (particle-3d-value-or-generator single-float)))
                          (values particle-3d-updater))
                particle-3d-spiral-updater))
(defun particle-3d-spiral-updater (origin target
                                   &key
                                     (angular-velocity (* (coerce pi 'single-float) 2.0))
                                     (axial-velocity 1.0)
                                     (axial-acceleration 0.0)
                                     (radius 1.0) (initial-phase 0.0))
  "Like PARTICLE-3D-LASER-UPDATER, but rotate particles around the emission axis with INITIAL-PHASE, ANGULAR-VELOCITY, and RADIUS."
  (with-value-generators (axial-velocity axial-acceleration angular-velocity origin target radius initial-phase)
    (declare (type (function (particle-3d) (values single-float)) axial-velocity axial-acceleration angular-velocity initial-phase)
             (type (function (particle-3d) (values single-float)) radius)
             (type (function (particle-3d) (values raylib:vector3)) origin target))
    (let ((particle-ages (make-hash-table)))
      (clet ((axis-x (cthe (:pointer (:struct raylib:vector3)) (& +vector3-unit-x+))))
        (lambda (particle)
          (if (zerop (particle-3d-age particle))
              (let ((origin (funcall origin particle))
                    (target (funcall target particle))
                    (angular-velocity (funcall angular-velocity particle))
                    (axial-velocity (funcall axial-velocity particle))
                    (axial-acceleration (funcall axial-acceleration particle)))
                (clet ((propagation (foreign-alloca '(:struct raylib:vector3)))
                       (origin (cthe (:pointer (:struct raylib:vector3)) (& origin)))
                       (target (cthe (:pointer (:struct raylib:vector3)) (& target))))
                  (raylib:%vector3-subtract propagation target origin)
                  (setf (particle-3d-lifetime particle) (uniformly-varied-linear-motion-time
                                                         axial-velocity axial-acceleration
                                                         (raylib:%vector3-length propagation)))
                  (let ((radius (funcall radius particle)) (initial-phase (funcall initial-phase particle)))
                    (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle))))
                      (raylib:%vector3-cross-product (& (-> particle position-velocity)) propagation axis-x)
                      (raylib:%vector3-rotate-by-axis-angle (& (-> particle position-velocity)) (& (-> particle position-velocity)) propagation initial-phase)
                      (raylib:%vector3-cross-product (& (-> particle position)) (& (-> particle position-velocity)) propagation)
                      (raylib:%vector3-normalize (& (-> particle position-velocity)) (& (-> particle position-velocity)))
                      (raylib:%vector3-scale (& (-> particle position-velocity)) (& (-> particle position-velocity)) (* angular-velocity radius))
                      
                      (raylib:%vector3-normalize (& (-> particle position-acceleration)) propagation)
                      (raylib:%vector3-scale (& (-> particle position-acceleration)) (& (-> particle position-acceleration)) axial-velocity)
                      (raylib:%vector3-add (& (-> particle position-velocity)) (& (-> particle position-velocity)) (& (-> particle position-acceleration)))
                      (raylib:%vector3-normalize (& (-> particle position-acceleration)) propagation)
                      (raylib:%vector3-scale (& (-> particle position-acceleration)) (& (-> particle position-acceleration)) axial-acceleration)
                      
                      (raylib:%vector3-normalize (& (-> particle position)) (& (-> particle position)))
                      (raylib:%vector3-scale (& (-> particle position)) (& (-> particle position)) radius)
                      (raylib:%vector3-add (& (-> particle position)) origin (& (-> particle position)))
                      (raylib:%quaternion-identity (& (-> particle rotation)))
                      (raylib:%quaternion-identity (& (-> particle rotation-velocity)))
                      (raylib:%quaternion-identity (& (-> particle rotation-acceleration)))))))
              (let ((origin (funcall origin particle)) (target (funcall target particle))
                    (angular-velocity (funcall angular-velocity particle))
                    (radius (funcall radius particle))
                    (delta (let* ((age (particle-3d-age particle))
                                  (previous-age (ensure-gethash particle particle-ages 0.0)))
                             (declare (type single-float age previous-age))
                             (prog1 (* (- age (if (< previous-age age) previous-age 0.0)) (particle-3d-lifetime particle))
                               (setf (gethash particle particle-ages) age)))))
                (clet ((particle (cthe (:pointer (:struct particle-3d)) (& particle)))
                       (propagation (foreign-alloca '(:struct raylib:vector3)))
                       (origin (cthe (:pointer (:struct raylib:vector3)) (& origin)))
                       (target (cthe (:pointer (:struct raylib:vector3)) (& target))))
                  (raylib:%vector3-subtract propagation target origin)
                  (raylib:%vector3-rotate-by-axis-angle (& (-> particle position-velocity)) (& (-> particle position-velocity)) propagation (* angular-velocity delta))
                  (let* ((previous-radius (/ (raylib:%vector3-length (& (-> particle position-velocity))) (abs angular-velocity)))
                         (tangential-velocity-scale (/ radius previous-radius)))
                    (raylib:%vector3-normalize propagation propagation)
                    (raylib:%vector3-scale propagation propagation (raylib:%vector3-dot-product propagation (& (-> particle position-velocity))))
                    (raylib:%vector3-subtract (& (-> particle position-velocity)) (& (-> particle position-velocity)) propagation)
                    (raylib:%vector3-scale (& (-> particle position-velocity)) (& (-> particle position-velocity)) tangential-velocity-scale)
                    (raylib:%vector3-add (& (-> particle position-velocity)) (& (-> particle position-velocity)) propagation)))
                (particle-3d-update-motion particle))))))))
